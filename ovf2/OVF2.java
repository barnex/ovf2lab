import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;

// OVF2 stores data from a single OOMMF OVF2 file (http://math.nist.gov/oommf) generated by mumax.
// There is no guarantee that non-mumax files are accepted.
class OVF2 {

	float[][][][] data;       // data index by component, z, y, x

	// Reads OVF2, binary 4 format, from in.
	static OVF2 read(InputStream in) throws IOException {

		String line = readline(in);

		if (!"# OOMMF OVF 2.0".equals(line)) {
			throw new IOException("invalid header: " + line);
		}


		int nComp =0, sizeX =0, sizeY =0, sizeZ = 0;

		line = readline(in);
		while (!"# End: Header".equals(line)) {
			line = line.substring(2);
			String[]split = line.split(":");
			String key = split[0].trim();
			String val = split[1].trim();
			if ("xnodes".equals(key)) {
				sizeX = Integer.parseInt(val);
			}
			if ("ynodes".equals(key)) {
				sizeY = Integer.parseInt(val);
			}
			if ("znodes".equals(key)) {
				sizeZ = Integer.parseInt(val);
			}
			if ("valuedim".equals(key)) {
				nComp = Integer.parseInt(val);
			}

			line = readline(in);
		}

		line = readline(in);
		if (! "# Begin: Data Binary 4".equals(line)) {
			throw new IOException("invalid data header: " + line);
		}

		// allocate data
		float[][][][] data = new float[nComp][][][];
		for(int c=0; c<data.length; c++) {
			data[c] = new float[sizeZ][][];
			for(int z=0; z<data[c].length; z++) {
				data[c][z] = new float[sizeY][];
				for(int y=0; y<data[c][z].length; y++) {
					data[c][z][y] = new float[sizeX];
				}
			}
		}


		// read data
		
		// get float from little-endian binary data.
		ByteBuffer buffer = ByteBuffer.allocate(4);
		buffer.put(3, readByte(in));
		buffer.put(2, readByte(in));
		buffer.put(1, readByte(in));
		buffer.put(0, readByte(in));
		float controlNumber = buffer.getFloat(0);

		if (controlNumber != 1234567.0) {
			throw new IOException("bad ovf2 control number: " + controlNumber);
		}

		for(int z=0; z<data[0].length; z++) {
			for(int y=0; y<data[0][z].length; y++) {
				for(int x=0; x<data[0][z][y].length; x++) {
					for(int c=0; c<data.length; c++) {
						buffer.put(3, readByte(in));
						buffer.put(2, readByte(in));
						buffer.put(1, readByte(in));
						buffer.put(0, readByte(in));
						data[c][z][y][x] = buffer.getFloat(0);
					}
				}
			}
		}

		OVF2 ovf2 = new OVF2();
		ovf2.data = data;
		return ovf2;
	}

	int sizeX() {
		return data[0][0][0].length;
	}

	int sizeY() {
		return data[0][0].length;
	}

	int sizeZ() {
		return data[0].length;
	}

	int nComp() {
		return data.length;
	}

	public String toString() {
		return "OVF2 " + nComp() + "x" + sizeX() + "x" + sizeY() + "x" + sizeZ();
	}

	// Reads a line from in.
	// Files are mixed text+binary, so BufferedReader et al. are problematic
	static String readline(InputStream in) throws IOException {
		StringBuilder str = new StringBuilder();
		byte b = readByte(in);
		while (b != '\n') {
			str.append((char)(b));
			b = readByte(in);
		}
		return str.toString();
	}

	static byte readByte(InputStream in) throws IOException {
		int b = in.read();
		if (b < 0) {
			throw new IOException("unexpected EOF");
		}
		return (byte)(b);
	}

	public static void main(String[] args)throws IOException {
		for(String arg: args) {
			OVF2 data = read(new FileInputStream(new File(arg)));
			System.out.println(data);
		}
	}
}
